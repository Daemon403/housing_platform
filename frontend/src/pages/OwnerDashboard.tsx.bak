import { useState, useEffect, useCallback } from 'react';
import { useAuth } from '../contexts/AuthContext';
import type { Listing, PaginatedListings } from '../types/listing';
import { listingService } from '../api/listingService';
import './OwnerDashboard.css';

interface PropertyFormData {
  title: string;
  description: string;
  price: string | number;
  address: string;
  latitude: number;
  longitude: number;
  bedrooms: string | number;
  bathrooms: string | number;
  size: string | number;
  propertyType: string;
  roomType: string;
  availableFrom: string;
  minStayMonths: string | number;
  maxOccupants: string | number;
  hasWifi: boolean;
  hasParking: boolean;
  hasKitchen: boolean;
  hasWasher: boolean;
  hasTv: boolean;
  hasAirConditioning: boolean;
  hasHeating: boolean;
  hasDesk: boolean;
  isFurnished: boolean;
  images: File[];
  location: {
    type: 'Point';
    coordinates: [number, number];
  };
}

interface PaginationState {
  currentPage: number;
  itemsPerPage: number;
  totalItems: number;
  totalPages: number;
}

type InputElement = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;

interface OwnerDashboardProps {}

const OwnerDashboard: React.FC<OwnerDashboardProps> = () => {
  const { token } = useAuth();
  
  // State management
  const [listings, setListings] = useState<Listing[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [showAddProperty, setShowAddProperty] = useState<boolean>(false);
  const [propertyImages, setPropertyImages] = useState<File[]>([]);
  
  // Pagination state
  const [pagination, setPagination] = useState<PaginationState>({
    currentPage: 1,
    itemsPerPage: 10,
    totalItems: 0,
    totalPages: 1
  });
  
  // Form state
  const [newProperty, setNewProperty] = useState<PropertyFormData>({
    title: '',
    description: '',
    price: '',
    address: '',
    latitude: 0,
    longitude: 0,
    bedrooms: 1,
    bathrooms: 1,
    size: 0,
    propertyType: 'apartment',
    roomType: 'entire_place',
    availableFrom: new Date().toISOString().split('T')[0],
    minStayMonths: 1,
    maxOccupants: 1,
    hasWifi: false,
    hasParking: false,
    hasKitchen: false,
    hasWasher: false,
    hasTv: false,
    hasAirConditioning: false,
    hasHeating: false,
    hasDesk: false,
    isFurnished: false,
    images: [],
    location: {
      type: 'Point',
      coordinates: [0, 0]
    }
  });
  
  // State management
  const [listings, setListings] = useState<Listing[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [showAddProperty, setShowAddProperty] = useState<boolean>(false);
  const [propertyImages, setPropertyImages] = useState<File[]>([]);
  
  // Pagination state
  const [pagination, setPagination] = useState<PaginationState>({
    currentPage: 1,
    itemsPerPage: 10,
    totalItems: 0,
    totalPages: 1
  });
  
  // Form state
  const [newProperty, setNewProperty] = useState<PropertyFormData>({
    title: '',
    description: '',
    price: '',
    address: '',
    latitude: 0,
    longitude: 0,
    bedrooms: 1,
    bathrooms: 1,
    size: 0,
    propertyType: 'apartment',
    roomType: 'entire_place',
    availableFrom: new Date().toISOString().split('T')[0],
    minStayMonths: 1,
    maxOccupants: 1,
    hasWifi: false,
    hasParking: false,
    hasKitchen: false,
    hasWasher: false,
    hasTv: false,
    hasAirConditioning: false,
    hasHeating: false,
    hasDesk: false,
    isFurnished: false,
    images: [],
    location: {
      type: 'Point',
      coordinates: [0, 0]
    }
  });
  
  // Fetch listings from API
  const fetchListings = useCallback(async (page = 1, limit = 10) => {
    if (!token) return;
    
    try {
      setLoading(true);
      const response = await listingService.getMyListings(token, page, limit);
      
      setListings(response.data || []);
      setPagination(prev => ({
        ...prev,
        currentPage: page,
        totalItems: response.pagination?.totalItems || 0,
        totalPages: response.pagination?.totalPages || 1
      }));
    } catch (err) {
      setError('Failed to fetch listings');
      console.error('Error fetching listings:', err);
    } finally {
      setLoading(false);
    }
  }, [token]);
  
  // Handle input changes
  const handleInputChange = (e: React.ChangeEvent<InputElement>) => {
    const { name, value, type } = e.target;
    setNewProperty(prev => ({
      ...prev,
      [name]: type === 'number' ? Number(value) : value
    }));
  };
  
  // Handle location changes
  const handleLocationChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    const numValue = parseFloat(value) || 0;
    
    setNewProperty(prev => {
      const coords: [number, number] = [...prev.location.coordinates];
      if (name === 'latitude') {
        coords[1] = numValue;
      } else if (name === 'longitude') {
        coords[0] = numValue;
      }
      
      return {
        ...prev,
        [name]: numValue,
        location: {
          ...prev.location,
          coordinates: coords
        }
      };
    });
  };
  
  // Handle checkbox changes
  const handleCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, checked } = e.target;
    setNewProperty(prev => ({
      ...prev,
      [name]: checked
    }));
  };
  
  // Handle image uploads
  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files) return;
    const files = Array.from(e.target.files);
    setPropertyImages(files);
    setNewProperty(prev => ({
      ...prev,
      images: files
    }));
  };
  
  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!token) return;
    
    try {
      setLoading(true);
      const formData = new FormData();
      
      // Prepare the listing data
      const listingData = {
        ...newProperty,
        price: Number(newProperty.price) || 0,
        bedrooms: Number(newProperty.bedrooms) || 1,
        bathrooms: Number(newProperty.bathrooms) || 1,
        size: Number(newProperty.size) || 0,
        minStayMonths: Number(newProperty.minStayMonths) || 1,
        maxOccupants: Number(newProperty.maxOccupants) || 1,
        location: {
          type: 'Point' as const,
          coordinates: [newProperty.longitude, newProperty.latitude]
        }
      };
      
      // Append all non-file fields
      Object.entries(listingData).forEach(([key, value]) => {
        if (key === 'images') return;
        if (value !== null && value !== undefined) {
          formData.append(
            key, 
            typeof value === 'object' 
              ? JSON.stringify(value) 
              : String(value)
          );
        }
      });
      
      // Append images
      propertyImages.forEach((file) => {
        formData.append('images', file);
      });
      
      // Submit the form with type assertion
      await listingService.createListing(formData as any, token);
      
      // Reset form and fetch updated listings
      setNewProperty({
        title: '',
        description: '',
        price: '',
        address: '',
        latitude: 0,
        longitude: 0,
        bedrooms: 1,
        bathrooms: 1,
        size: 0,
        propertyType: 'apartment',
        roomType: 'entire_place',
        availableFrom: new Date().toISOString().split('T')[0],
        minStayMonths: 1,
        maxOccupants: 1,
        hasWifi: false,
        hasParking: false,
        hasKitchen: false,
        hasWasher: false,
        hasTv: false,
        hasAirConditioning: false,
        hasHeating: false,
        hasDesk: false,
        isFurnished: false,
        images: [],
        location: {
          type: 'Point',
          coordinates: [0, 0]
        }
      });
      setPropertyImages([]);
      setShowAddProperty(false);
      await fetchListings(pagination.currentPage, pagination.itemsPerPage);
      
    } catch (err) {
      setError('Failed to create listing');
      console.error('Error creating listing:', err);
    } finally {
      setLoading(false);
    }
  };
  
  // Handle listing deletion
  const handleDeleteListing = async (id: string) => {
    if (!token || !window.confirm('Are you sure you want to delete this listing?')) {
      return;
    }
    
    try {
      setLoading(true);
      await listingService.deleteListing(id, token);
      
      // Refresh the listings after deletion
      await fetchListings(pagination.currentPage, pagination.itemsPerPage);
    } catch (err) {
      setError('Failed to delete listing');
      console.error('Error deleting listing:', err);
    } finally {
      setLoading(false);
    }
  };
  
  // Handle page change
  const handlePageChange = (newPage: number) => {
    setPagination(prev => ({
      ...prev,
      currentPage: newPage
    }));
  };
  
  // Fetch listings when component mounts or pagination changes
  useEffect(() => {
    fetchListings(pagination.currentPage, pagination.itemsPerPage);
  }, [fetchListings, pagination.currentPage, pagination.itemsPerPage]);
  
  // Render the component
  return (
    <div className="dashboard-container">
      <div className="dashboard-header">
        <h1>My Properties</h1>
        <button 
          className="btn btn-primary"
          onClick={() => setShowAddProperty(true)}
        >
          Add New Property
        </button>
      </div>
      
      {error && <div className="alert alert-danger">{error}</div>}
      
      {loading ? (
        <div className="text-center">Loading...</div>
      ) : (
        <div className="property-list">
          {listings.length === 0 ? (
            <div className="no-properties">
              <p>You don't have any properties listed yet.</p>
            </div>
          ) : (
            <div className="properties-grid">
              {listings.map((listing) => (
                <div key={listing.id} className="property-card">
                  <div className="property-image">
                    {listing.images && listing.images.length > 0 ? (
                      <img 
                        src={listing.images[0]} 
                        alt={listing.title} 
                        className="img-fluid"
                      />
                    ) : (
                      <div className="no-image">No Image</div>
                    )}
                  </div>
                  <div className="property-details">
                    <h3>{listing.title}</h3>
                    <p className="price">${listing.price}/month</p>
                    <p className="address">{listing.address}</p>
                    <div className="property-meta">
                      <span>{listing.bedrooms} bd</span>
                      <span>{listing.bathrooms} ba</span>
                      <span>{listing.size} sqft</span>
                    </div>
                    <div className="property-actions">
                      <button 
                        className="btn btn-sm btn-outline-primary"
                        onClick={() => {}}
                      >
                        Edit
                      </button>
                      <button 
                        className="btn btn-sm btn-outline-danger"
                        onClick={() => handleDeleteListing(listing.id)}
                      >
                        Delete
                      </button>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}
          
          {/* Pagination */}
          {pagination.totalPages > 1 && (
            <div className="pagination">
              <button 
                className="btn btn-sm"
                disabled={pagination.currentPage === 1}
                onClick={() => handlePageChange(pagination.currentPage - 1)}
              >
                Previous
              </button>
              <span>
                Page {pagination.currentPage} of {pagination.totalPages}
              </span>
              <button 
                className="btn btn-sm"
                disabled={pagination.currentPage === pagination.totalPages}
                onClick={() => handlePageChange(pagination.currentPage + 1)}
              >
                Next
              </button>
            </div>
          )}
        </div>
      )}
      
      {/* Add Property Modal */}
      {showAddProperty && (
        <div className="modal-overlay">
          <div className="modal-content">
            <div className="modal-header">
              <h2>Add New Property</h2>
              <button 
                className="close-btn"
                onClick={() => setShowAddProperty(false)}
              >
                &times;
              </button>
            </div>
            <div className="modal-body">
              <form onSubmit={handleSubmit}>
                <div className="form-group">
                  <label htmlFor="title">Title *</label>
                  <input
                    type="text"
                    id="title"
                    name="title"
                    value={newProperty.title}
                    onChange={handleInputChange}
                    required
                    className="form-control"
                  />
                </div>
                
                <div className="form-group">
                  <label htmlFor="description">Description</label>
                  <textarea
                    id="description"
                    name="description"
                    value={newProperty.description}
                    onChange={handleInputChange}
                    rows={4}
                    className="form-control"
                  />
                </div>
                
                <div className="form-row">
                  <div className="form-group col-md-6">
                    <label htmlFor="price">Price per month *</label>
                    <div className="input-group">
                      <div className="input-group-prepend">
                        <span className="input-group-text">$</span>
                      </div>
                      <input
                        type="number"
                        id="price"
                        name="price"
                        value={newProperty.price}
                        onChange={handleInputChange}
                        min="0"
                        step="1"
                        required
                        className="form-control"
                      />
                    </div>
                  </div>
                  
                  <div className="form-group col-md-6">
                    <label htmlFor="propertyType">Property Type *</label>
                    <select
                      id="propertyType"
                      name="propertyType"
                      value={newProperty.propertyType}
                      onChange={handleInputChange}
                      required
                      className="form-control"
                    >
                      <option value="apartment">Apartment</option>
                      <option value="house">House</option>
                      <option value="condo">Condo</option>
                      <option value="townhouse">Townhouse</option>
                      <option value="studio">Studio</option>
                    </select>
                  </div>
                </div>
                
                <div className="form-group">
                  <label htmlFor="address">Address *</label>
                  <input
                    type="text"
                    id="address"
                    name="address"
                    value={newProperty.address}
                    onChange={handleInputChange}
                    required
                    className="form-control"
                  />
                </div>
                
                <div className="form-row">
                  <div className="form-group col-md-6">
                    <label htmlFor="latitude">Latitude</label>
                    <input
                      type="number"
                      id="latitude"
                      name="latitude"
                      value={newProperty.latitude}
                      onChange={handleLocationChange}
                      step="0.000001"
                      className="form-control"
                    />
                  </div>
                  
                  <div className="form-group col-md-6">
                    <label htmlFor="longitude">Longitude</label>
                    <input
                      type="number"
                      id="longitude"
                      name="longitude"
                      value={newProperty.longitude}
                      onChange={handleLocationChange}
                      step="0.000001"
                      className="form-control"
                    />
                  </div>
                </div>
                
                <div className="form-row">
                  <div className="form-group col-md-4">
                    <label htmlFor="bedrooms">Bedrooms *</label>
                    <input
                      type="number"
                      id="bedrooms"
                      name="bedrooms"
                      value={newProperty.bedrooms}
                      onChange={handleInputChange}
                      min="0"
                      required
                      className="form-control"
                    />
                  </div>
                  
                  <div className="form-group col-md-4">
                    <label htmlFor="bathrooms">Bathrooms *</label>
                    <input
                      type="number"
                      id="bathrooms"
                      name="bathrooms"
                      value={newProperty.bathrooms}
                      onChange={handleInputChange}
                      min="0"
                      step="0.5"
                      required
                      className="form-control"
                    />
                  </div>
                  
                  <div className="form-group col-md-4">
                    <label htmlFor="size">Size (sq ft)</label>
                    <input
                      type="number"
                      id="size"
                      name="size"
                      value={newProperty.size}
                      onChange={handleInputChange}
                      min="0"
                      className="form-control"
                    />
                  </div>
                </div>
                
                <div className="form-row">
                  <div className="form-group col-md-6">
                    <label htmlFor="roomType">Room Type *</label>
                    <select
                      id="roomType"
                      name="roomType"
                      value={newProperty.roomType}
                      onChange={handleInputChange}
                      required
                      className="form-control"
                    >
                      <option value="entire_place">Entire Place</option>
                      <option value="private_room">Private Room</option>
                      <option value="shared_room">Shared Room</option>
                    </select>
                  </div>
                  
                  <div className="form-group col-md-6">
                    <label htmlFor="availableFrom">Available From *</label>
                    <input
                      type="date"
                      id="availableFrom"
                      name="availableFrom"
                      value={newProperty.availableFrom}
                      onChange={handleInputChange}
                      required
                      className="form-control"
                    />
                  </div>
                </div>
                
                <div className="form-row">
                  <div className="form-group col-md-6">
                    <label htmlFor="minStayMonths">Minimum Stay (months) *</label>
                    <input
                      type="number"
                      id="minStayMonths"
                      name="minStayMonths"
                      value={newProperty.minStayMonths}
                      onChange={handleInputChange}
                      min="1"
                      required
                      className="form-control"
                    />
                  </div>
                  
                  <div className="form-group col-md-6">
                    <label htmlFor="maxOccupants">Maximum Occupants *</label>
                    <input
                      type="number"
                      id="maxOccupants"
                      name="maxOccupants"
                      value={newProperty.maxOccupants}
                      onChange={handleInputChange}
                      min="1"
                      required
                      className="form-control"
                    />
                  </div>
                </div>
                
                <div className="form-group">
                  <label>Amenities</label>
                  <div className="amenities-grid">
                    <div className="form-check">
                      <input
                        type="checkbox"
                        id="hasWifi"
                        name="hasWifi"
                        checked={newProperty.hasWifi}
                        onChange={handleCheckboxChange}
                        className="form-check-input"
                      />
                      <label className="form-check-label" htmlFor="hasWifi">WiFi</label>
                    </div>
                    
                    <div className="form-check">
                      <input
                        type="checkbox"
                        id="hasParking"
                        name="hasParking"
                        checked={newProperty.hasParking}
                        onChange={handleCheckboxChange}
                        className="form-check-input"
                      />
                      <label className="form-check-label" htmlFor="hasParking">Parking</label>
                    </div>
                    
                    <div className="form-check">
                      <input
                        type="checkbox"
                        id="hasKitchen"
                        name="hasKitchen"
                        checked={newProperty.hasKitchen}
                        onChange={handleCheckboxChange}
                        className="form-check-input"
                      />
                      <label className="form-check-label" htmlFor="hasKitchen">Kitchen</label>
                    </div>
                    
                    <div className="form-check">
                      <input
                        type="checkbox"
                        id="hasWasher"
                        name="hasWasher"
                        checked={newProperty.hasWasher}
                        onChange={handleCheckboxChange}
                        className="form-check-input"
                      />
                      <label className="form-check-label" htmlFor="hasWasher">Washer</label>
                    </div>
                    
                    <div className="form-check">
                      <input
                        type="checkbox"
                        id="hasTv"
                        name="hasTv"
                        checked={newProperty.hasTv}
                        onChange={handleCheckboxChange}
                        className="form-check-input"
                      />
                      <label className="form-check-label" htmlFor="hasTv">TV</label>
                    </div>
                    
                    <div className="form-check">
                      <input
                        type="checkbox"
                        id="hasAirConditioning"
                        name="hasAirConditioning"
                        checked={newProperty.hasAirConditioning}
                        onChange={handleCheckboxChange}
                        className="form-check-input"
                      />
                      <label className="form-check-label" htmlFor="hasAirConditioning">Air Conditioning</label>
                    </div>
                    
                    <div className="form-check">
                      <input
                        type="checkbox"
                        id="hasHeating"
                        name="hasHeating"
                        checked={newProperty.hasHeating}
                        onChange={handleCheckboxChange}
                        className="form-check-input"
                      />
                      <label className="form-check-label" htmlFor="hasHeating">Heating</label>
                    </div>
                    
                    <div className="form-check">
                      <input
                        type="checkbox"
                        id="hasDesk"
                        name="hasDesk"
                        checked={newProperty.hasDesk}
                        onChange={handleCheckboxChange}
                        className="form-check-input"
                      />
                      <label className="form-check-label" htmlFor="hasDesk">Desk</label>
                    </div>
                    
                    <div className="form-check">
                      <input
                        type="checkbox"
                        id="isFurnished"
                        name="isFurnished"
                        checked={newProperty.isFurnished}
                        onChange={handleCheckboxChange}
                        className="form-check-input"
                      />
                      <label className="form-check-label" htmlFor="isFurnished">Furnished</label>
                    </div>
                  </div>
                </div>
                
                <div className="form-group">
                  <label htmlFor="images">Property Images</label>
                  <input
                    type="file"
                    id="images"
                    name="images"
                    onChange={handleImageUpload}
                    multiple
                    accept="image/*"
                    className="form-control-file"
                  />
                  <small className="form-text text-muted">
                    You can select multiple images (JPEG, PNG, etc.)
                  </small>
                </div>
                
                {propertyImages.length > 0 && (
                  <div className="image-previews">
                    <h5>Selected Images:</h5>
                    <div className="preview-grid">
                      {propertyImages.map((file, index) => (
                        <div key={index} className="preview-item">
                          <img 
                            src={URL.createObjectURL(file)} 
                            alt={`Preview ${index + 1}`} 
                            className="img-thumbnail"
                          />
                        </div>
                      ))}
                    </div>
                  </div>
                )}
                
                <div className="form-actions">
                  <button 
                    type="button" 
                    className="btn btn-secondary"
                    onClick={() => setShowAddProperty(false)}
                  >
                    Cancel
                  </button>
                  <button 
                    type="submit" 
                    className="btn btn-primary"
                    disabled={loading}
                  >
                    {loading ? 'Saving...' : 'Save Property'}
                  </button>
                </div>
              </form>
            </div>
          </div>
        </div>
      )}
    </div>
  );
    totalItems: 0,
    totalPages: 1
  });
  
  const initialFormState: PropertyFormData = {
    title: '',
    description: '',
    price: '',
    address: '',
    latitude: 0,
    longitude: 0,
    bedrooms: 1,
    bathrooms: 1,
    size: 0,
    propertyType: 'apartment',
    roomType: 'entire_place',
    availableFrom: new Date().toISOString().split('T')[0],
    minStayMonths: 1,
    maxOccupants: 1,
    hasWifi: false,
    hasParking: false,
    hasKitchen: false,
    hasWasher: false,
    hasTv: false,
    hasAirConditioning: false,
    hasHeating: false,
    hasDesk: false,
    isFurnished: false,
    images: [],
    location: {
      type: 'Point',
      coordinates: [0, 0]
    }
  };
  
  const [newProperty, setNewProperty] = useState<PropertyFormData>(initialFormState);
  
  // Memoize the fetchListings function
  const fetchListings = useCallback(async (page = 1, limit = 10) => {
    if (!token) return;
    
    try {
      setLoading(true);
      const response = await listingService.getMyListings(token, page, limit);
      
      setListings(response.data || []);
      setPagination(prev => ({
        ...prev,
        currentPage: page,
        totalItems: response.pagination?.totalItems || 0,
        totalPages: response.pagination?.totalPages || 1
      }));
    } catch (err) {
      setError('Failed to fetch listings');
      console.error('Error fetching listings:', err);
    } finally {
      setLoading(false);
    }
  }, [token]);
  
  // Handle input changes
  const handleInputChange = (e: React.ChangeEvent<InputElement>) => {
    const { name, value, type } = e.target;
    setNewProperty(prev => ({
      ...prev,
      [name]: type === 'number' ? Number(value) : value
    }));
  };
  
  // Handle location changes
  const handleLocationChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    const numValue = parseFloat(value) || 0;
    
    setNewProperty(prev => {
      const coords: [number, number] = [...prev.location.coordinates];
      if (name === 'latitude') {
        coords[1] = numValue;
      } else if (name === 'longitude') {
        coords[0] = numValue;
      }
      
      return {
        ...prev,
        [name]: numValue,
        location: {
          ...prev.location,
          coordinates: coords
        }
      };
    });
  };
  
  // Handle checkbox changes
  const handleCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, checked } = e.target;
    setNewProperty(prev => ({
      ...prev,
      [name]: checked
    }));
  };
  
  // Handle image uploads
  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files) return;
    const files = Array.from(e.target.files);
    setPropertyImages(files);
    setNewProperty(prev => ({
      ...prev,
      images: files
    }));
  };
  
  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!token) return;
    
    try {
      setLoading(true);
      const formData = new FormData();
      
      // Prepare the listing data
      const listingData = {
        ...newProperty,
        price: Number(newProperty.price) || 0,
        bedrooms: Number(newProperty.bedrooms) || 1,
        bathrooms: Number(newProperty.bathrooms) || 1,
        size: Number(newProperty.size) || 0,
        minStayMonths: Number(newProperty.minStayMonths) || 1,
        maxOccupants: Number(newProperty.maxOccupants) || 1,
        location: {
          type: 'Point' as const,
          coordinates: [newProperty.longitude, newProperty.latitude]
        }
      };
      
      // Append all non-file fields
      Object.entries(listingData).forEach(([key, value]) => {
        if (key === 'images') return;
        if (value !== null && value !== undefined) {
          formData.append(
            key, 
            typeof value === 'object' 
              ? JSON.stringify(value) 
              : String(value)
          );
        }
      });
      
      // Append images
      propertyImages.forEach((file) => {
        formData.append('images', file);
      });
      
      // Submit the form
      await listingService.createListing(formData, token);
      
      // Reset form and fetch updated listings
      setNewProperty(initialFormState);
      setPropertyImages([]);
      setShowAddProperty(false);
      await fetchListings(pagination.currentPage, pagination.itemsPerPage);
      
    } catch (err) {
      setError('Failed to create listing');
      console.error('Error creating listing:', err);
    } finally {
      setLoading(false);
    }
  };
  
  // Handle listing deletion
  const handleDeleteListing = async (id: string) => {
    if (!token || !window.confirm('Are you sure you want to delete this listing?')) {
      return;
    }
    
    try {
      setLoading(true);
      await listingService.deleteListing(id, token);
      
      // Refresh the listings after deletion
      await fetchListings(pagination.currentPage, pagination.itemsPerPage);
    } catch (err) {
      setError('Failed to delete listing');
      console.error('Error deleting listing:', err);
    } finally {
      setLoading(false);
    }
  };
  
  // Handle page change
  const handlePageChange = (newPage: number) => {
    setPagination(prev => ({
      ...prev,
      currentPage: newPage
    }));
  };
  
  // Fetch listings when component mounts or pagination changes
  useEffect(() => {
    fetchListings(pagination.currentPage, pagination.itemsPerPage);
  }, [fetchListings, pagination.currentPage, pagination.itemsPerPage]);

  // Fetch listings from the API
  const fetchListings = useCallback(async () => {
    if (!token) return;
    
    try {
      setLoading(true);
      const response: PaginatedListings = await listingService.getMyListings(
        token,
        pagination.currentPage,
        pagination.itemsPerPage
      );
      
      setListings(response.data || []);
      setPagination(prev => ({
        ...prev,
        totalItems: response.pagination?.totalItems || 0,
        totalPages: response.pagination?.totalPages || 1
      }));
    } catch (err) {
      setError('Failed to fetch listings');
      console.error('Error fetching listings:', err);
    } finally {
      setLoading(false);
    }
  }, [token, pagination.currentPage, pagination.itemsPerPage]);

  // Fetch listings on component mount
  useEffect(() => {
    fetchListings();
  }, [fetchListings]);

  // Handle input changes
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value, type } = e.target;
    setNewProperty(prev => ({
      ...prev,
      [name]: type === 'number' ? Number(value) : value
    }));
  };

  // Handle location changes
  const handleLocationChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    const numValue = parseFloat(value) || 0;
    
    setNewProperty(prev => {
      const coords: [number, number] = [...prev.location.coordinates] as [number, number];
      if (name === 'latitude') {
        coords[1] = numValue;
        return { 
          ...prev, 
          latitude: numValue, 
          location: { 
            ...prev.location, 
            coordinates: coords 
          } 
        };
      } else if (name === 'longitude') {
        coords[0] = numValue;
        return { 
          ...prev, 
          longitude: numValue, 
          location: { 
            ...prev.location, 
            coordinates: coords 
          } 
        };
      }
      return prev;
    });
  };

  // Handle checkbox changes
  const handleCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, checked } = e.target;
    setNewProperty(prev => ({
      ...prev,
      [name]: checked
    }));
  };

  // Handle image uploads
  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files) return;
    const files = Array.from(e.target.files);
    setPropertyImages(files);
    setNewProperty(prev => ({
      ...prev,
      images: files
    }));
  };

  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!token) return;
    
    try {
      setLoading(true);
      const formData = new FormData();
      
      // Append all form fields to formData
      Object.entries(newProperty).forEach(([key, value]) => {
        if (key === 'images') return; // Handle images separately
        if (value !== null && value !== undefined) {
          formData.append(
            key,
            typeof value === 'object' 
              ? JSON.stringify(value) 
              : String(value)
          );
        }
      });
      
      // Append images
      if (propertyImages.length > 0) {
        propertyImages.forEach((file, index) => {
          formData.append('images', file);
        });
      }
      
      // Submit the form data
      await listingService.createListing(formData, token);
      
      // Reset form and fetch updated listings
      setNewProperty(initialFormState);
      setPropertyImages([]);
      setShowAddProperty(false);
      fetchListings();
      
    } catch (err) {
      setError('Failed to create listing');
      console.error('Error creating listing:', err);
    } finally {
      setLoading(false);
    }
  };

  // Handle listing deletion
  const handleDeleteListing = async (id: string) => {
    if (!token || !window.confirm('Are you sure you want to delete this listing?')) {
      return;
    }
    
    try {
      setLoading(true);
      await listingService.deleteListing(id, token);
      // Refresh the listings after deletion
      await fetchListings();
    } catch (err) {
      setError('Failed to delete listing');
      console.error('Error deleting listing:', err);
    } finally {
      setLoading(false);
    }
  };
      // Initialize pagination if needed
      if (!pagination) {
        setPagination({
          currentPage: 1,
          itemsPerPage: 10,
          totalItems: response.pagination?.totalItems || 0,
          totalPages: response.pagination?.totalPages || 1
        });
      } else {
        setPagination(prev => ({
          ...prev,
          totalItems: response.pagination?.totalItems || 0,
          totalPages: response.pagination?.totalPages || 1
        }));
      }
    } catch (err) {
      setError('Failed to fetch listings');
      console.error('Error fetching listings:', err);
    } finally {
      setLoading(false);
    }
  }, [token, pagination]);

  // Handle input changes
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value, type } = e.target as HTMLInputElement;
    
    setNewProperty(prev => ({
      ...prev,
      [name]: type === 'number' ? Number(value) : value
    }));
  };

  // Handle location changes
  const handleLocationChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    const numValue = parseFloat(value) || 0;
    
    setNewProperty(prev => {
      const coords: [number, number] = [...prev.location.coordinates] as [number, number];
      if (name === 'latitude') {
        coords[1] = numValue;
        return { 
          ...prev, 
          latitude: numValue, 
          location: { 
            ...prev.location, 
            coordinates: coords 
          } 
        };
      } else if (name === 'longitude') {
        coords[0] = numValue;
        return { 
          ...prev, 
          longitude: numValue, 
          location: { 
            ...prev.location, 
            coordinates: coords 
          } 
        };
      }
      return prev;
    });
  };

  // Handle checkbox changes
  const handleCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, checked } = e.target;
    setNewProperty(prev => ({
      ...prev,
      [name]: checked
    }));
  };

  // Handle image upload
  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files) return;
    
    const newImages = Array.from(files);
    setPropertyImages(prev => [...prev, ...newImages]);
    
    setNewProperty(prev => ({
      ...prev,
      images: [...prev.images, ...newImages]
    }));
  };

  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!token) return;
    
    try {
      setLoading(true);
      const formData = new FormData();
      
      // Prepare the listing data
      const listingData = {
        ...newProperty,
        price: Number(newProperty.price) || 0,
        bedrooms: Number(newProperty.bedrooms) || 1,
        bathrooms: Number(newProperty.bathrooms) || 1,
        size: Number(newProperty.size) || 0,
        minStayMonths: Number(newProperty.minStayMonths) || 1,
        maxOccupants: Number(newProperty.maxOccupants) || 1,
        location: {
          type: 'Point' as const,
          coordinates: [newProperty.longitude, newProperty.latitude] as [number, number]
        }
      };
      
      // Append all non-file fields
      Object.entries(listingData).forEach(([key, value]) => {
        if (key === 'images') return;
        if (value !== null && value !== undefined) {
          formData.append(
            key, 
            typeof value === 'object' 
              ? JSON.stringify(value) 
              : String(value)
          );
        }
      });
      
      // Append images
      propertyImages.forEach((file) => {
        formData.append('images', file);
      });
      
      // Submit the form
      await listingService.createListing(token, formData);
      
      // Refresh the listings and reset form
      await fetchListings();
      setShowAddProperty(false);
      setNewProperty(initialFormState);
      setPropertyImages([]);
    } catch (err) {
      setError('Failed to create listing');
      console.error('Error creating listing:', err);
    } finally {
      setLoading(false);
    }
  };

  // Handle listing deletion
  const handleDeleteListing = async (id: string) => {
    if (!token) return;
    
    if (window.confirm('Are you sure you want to delete this listing?')) {
      try {
        setLoading(true);
        await listingService.deleteListing(token, id);
        await fetchListings();
      } catch (err) {
        setError('Failed to delete listing');
        console.error('Error deleting listing:', err);
      } finally {
        setLoading(false);
      }
    }
  };

  // Define a type for the property form data
  type PropertyFormData = Omit<ListingType, 'id' | 'createdAt' | 'updatedAt' | 'owner' | 'bookings' | 'slug' | 'price' | 'address' | 'location' | 'images'> & {
    price: string | number;
    address: string;
    latitude: number;
    longitude: number;
    location: {
      type: 'Point';
      coordinates: [number, number];
    };
    propertyType: string;
    roomType: string;
    availableFrom: string;
    minStayMonths: string | number;
    maxOccupants: string | number;
    bedrooms: string | number;
    bathrooms: string | number;
    size: string | number;
    images: string[];
    hasWifi: boolean;
    hasParking: boolean;
    hasKitchen: boolean;
    hasWasher: boolean;
    hasTv: boolean;
    hasAirConditioning: boolean;
    hasHeating: boolean;
    hasDesk: boolean;
    isFurnished: boolean;
  };

  // Fetch listings from the API
  const fetchListings = async (page = 1, limit = 10) => {
    try {
      const response = await api.getListings({ page, pageSize: limit });
      
      if (Array.isArray(response)) {
        // Ensure all listings have required fields
        const formattedListings = response.map(listing => ({
          ...listing,
          id: listing.id || '', // Ensure id is not undefined
          bookings: listing.bookings || [],
          images: listing.images || []
        }));
        
        setListings(formattedListings);
        setPagination(prev => ({
          ...prev,
          currentPage: page,
          itemsPerPage: limit,
          totalItems: response.length,
          totalPages: Math.ceil(response.length / limit)
        }));
      }
    } catch (err) {
      const error = err as Error;
      console.error('Error fetching listings:', error);
      setError(`Failed to fetch listings: ${error.message}`);
    }
  };

  const [newProperty, setNewProperty] = useState<PropertyFormData>({
    title: '',
    description: '',
    price: '',
    address: '',
    location: {
      type: 'Point',
      coordinates: [0, 0]
    },
    latitude: 0,
    longitude: 0,
    propertyType: 'apartment',
    roomType: 'private',
    status: 'available',
    availableFrom: new Date().toISOString().split('T')[0],
    minStayMonths: 1,
    maxOccupants: 1,
    bedrooms: 1,
    bathrooms: 1,
    size: 50,
    hasWifi: false,
    hasParking: false,
    hasKitchen: false,
    hasWasher: false,
    hasTv: false,
    hasAirConditioning: false,
    hasHeating: false,
    hasDesk: false,
    isFurnished: false
  });

  const [newProperty, setNewProperty] = useState<PropertyFormData>({
    title: '',
    description: '',
    price: '',
    address: '',
    location: {
      type: 'Point',
      coordinates: [0, 0]
    },
    latitude: 0,
    longitude: 0,
    propertyType: 'apartment',
    roomType: 'private',
    status: 'available',
    availableFrom: new Date().toISOString().split('T')[0],
    minStayMonths: 1,
    maxOccupants: 1,
    bedrooms: 1,
    bathrooms: 1,
    size: 50,
    hasWifi: false,
    hasParking: false,
    hasKitchen: false,
    hasWasher: false,
    hasTv: false,
    hasAirConditioning: false,
    hasHeating: false,
    hasDesk: false,
    isFurnished: false
  });

  const [newProperty, setNewProperty] = useState<PropertyFormData>({
    title: '',
    description: '',
    price: '',
    address: '',
    location: {
      type: 'Point',
      coordinates: [0, 0]
    },
    latitude: 0,
    longitude: 0,
    propertyType: 'apartment',
    roomType: 'private-room',
    availableFrom: new Date().toISOString().split('T')[0],
    minStayMonths: 1,
    maxOccupants: 1,
    bedrooms: 1,
    bathrooms: 1,
    size: 50,
    isFurnished: false,
    hasParking: false,
    hasWifi: false,
    hasKitchen: false,
    hasAirConditioning: false,
    hasHeating: false,
    hasWasher: false,
    hasTv: false,
    hasDesk: false,
    status: 'pending',
    images: [],
  });

  const [propertyImages, setPropertyImages] = useState<File[]>([]);

  const fetchListings = async (page = 1, limit = 10) => {
    try {
      const token = localStorage.getItem('token');
      if (!token) {
        console.error('No authentication token found in localStorage');
        throw new Error('No authentication token found');
      }

      const queryParams = new URLSearchParams({
        page: page.toString(),
        limit: limit.toString()
      });

      const apiUrl = `${import.meta.env.VITE_API_URL || 'http://localhost:5000'}/api/v1/listings/me?${queryParams}`;
      console.log('Fetching listings from:', apiUrl);

      const response = await fetch(apiUrl, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        credentials: 'include',
      });

      console.log('Response status:', response.status);

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        console.error('API Error Response:', errorData);
        throw new Error(errorData.message || `Failed to fetch listings: ${response.statusText}`);
      }

      const responseData = await response.json();
      console.log('=== LISTINGS DATA ===');
      
      // Handle both response formats: { success, data } and direct array
      let listingsData = [];
      if (Array.isArray(responseData)) {
        // Direct array response
        listingsData = responseData;
      } else if (responseData && responseData.success && Array.isArray(responseData.data)) {
        // Response with success and data properties
        listingsData = responseData.data;
      } else if (responseData && Array.isArray(responseData.listings)) {
        // Response with listings property
        listingsData = responseData.listings;
      }
        console.log(`Fetched ${listingsData.length} listings`);
        
        // Log detailed image information for each listing
        listingsData.forEach((listing: any, index: number) => {
          console.log(`\nListing #${index + 1} (ID: ${listing.id}) - ${listing.title}`);
          console.log('Has images array?', Array.isArray(listing.images));
          console.log('Number of images:', listing.images?.length || 0);
          if (listing.images?.length > 0) {
            console.log('Image paths:', listing.images);
            // Log the first image URL with full path for testing
            const firstImage = listing.images[0];
            const fullImageUrl = firstImage.startsWith('http') 
              ? firstImage 
              : `${import.meta.env.VITE_API_URL || 'http://localhost:5000'}/${firstImage.replace(/^[\\/]+/, '')}`;
            console.log('First image URL:', fullImageUrl);
          } else {
            console.log('No images found for this listing');
          }
        });
        
        setListings(listingsData);
        setPagination(prev => ({
          ...prev,
          currentPage: page,
          totalPages: responseData.pages || 1,
          totalItems: responseData.total || listingsData.length
        }));
      } else {
        console.warn('Unexpected response format:', responseData);
        setListings([]);
      }
      
      setError(null);
    } catch (err) {
      console.error('Error in fetchListings:', {
        message: err instanceof Error ? err.message : 'Unknown error',
        error: err,
        timestamp: new Date().toISOString()
      });
      setError(`Failed to load your properties. ${err instanceof Error ? err.message : 'Please try again later.'}`);
      setListings([]);
    } finally {
      setShowDebug(false);
    }
  };

  const handleDeleteListing = async (id: string) => {
    if (window.confirm('Are you sure you want to delete this listing?')) {
      try {
        const token = localStorage.getItem('token');
        if (!token) throw new Error('No authentication token found');

        const response = await fetch(`${import.meta.env.VITE_API_URL || 'http://localhost:5000'}/api/v1/listings/${id}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${token}`,
          },
        });

        if (!response.ok) {
          throw new Error('Failed to delete listing');
        }

        fetchListings();
      } catch (error) {
        console.error('Error deleting listing:', error);
        alert('Failed to delete listing. Please try again.');
      }
    }
  };

  // Handle input changes for the property form
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value, type } = e.target as HTMLInputElement;
    
    setNewProperty(prev => ({
      ...prev,
      [name]: type === 'number' || type === 'range' 
        ? value === '' 
          ? '' 
          : parseFloat(value)
        : type === 'checkbox'
        ? (e.target as HTMLInputElement).checked
        : value
    }));
  };

  const handleAddProperty = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const token = localStorage.getItem('token');
      if (!token) {
        throw new Error('No authentication token found. Please log in again.');
      }

      // Validate required fields
      if (!newProperty.title || !newProperty.price || !newProperty.address) {
        throw new Error('Please fill in all required fields (title, price, address)');
      }

// Prepare property data for API
      const propertyData: Partial<ListingType> & { price: number } = {
        title: newProperty.title,
        description: newProperty.description,
        price: parseFloat(String(newProperty.price)) || 0,
        address: newProperty.address,
        location: {
          type: 'Point',
          coordinates: [newProperty.longitude, newProperty.latitude] as [number, number]
        },
        propertyType: newProperty.propertyType || 'apartment',
        roomType: newProperty.roomType || 'private-room',
        availableFrom: newProperty.availableFrom || new Date().toISOString().split('T')[0],
        minStayMonths: Number(newProperty.minStayMonths) || 1,
        maxOccupants: Number(newProperty.maxOccupants) || 1,
        bedrooms: Number(newProperty.bedrooms) || 1,
        bathrooms: Number(newProperty.bathrooms) || 1,
        size: Number(newProperty.size) || 50,
        isFurnished: newProperty.isFurnished,
        hasParking: newProperty.hasParking,
        hasWifi: newProperty.hasWifi,
        hasKitchen: newProperty.hasKitchen,
        hasAirConditioning: newProperty.hasAirConditioning,
        hasHeating: newProperty.hasHeating,
        hasWasher: newProperty.hasWasher,
        hasTv: newProperty.hasTv,
        hasDesk: newProperty.hasDesk,
        status: 'pending',
        images: [],
      };

      console.log('Creating property with data:', propertyData);

      // Step 1: Create the property
      let response;
      try {
        response = await api.createListing(token, propertyData);
        console.log('Property creation response:', response);
      } catch (error) {
        console.error('Error creating property:', error);
        throw new Error(`Failed to create property: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }

      // Handle the nested response structure
      const createdProperty = response.data || response;
      const propertyId = createdProperty?.id || createdProperty?._id;
      
      if (!propertyId) {
        console.error('Invalid property creation response - missing ID:', response);
        throw new Error('Failed to create property: No property ID returned from server');
      }

      // Step 2: Upload images if any
      if (propertyImages.length > 0) {
        try {
          console.log('Uploading images for property:', propertyId);
          await api.uploadListingImages(token, propertyId, propertyImages);
          console.log('Images uploaded successfully');
        } catch (uploadError) {
          console.error('Error uploading images:', uploadError);
          // Continue with the flow even if image upload fails
        }
      }

      // Reset form and fetch updated listings
      setNewProperty({
        title: '',
        description: '',
        price: '',
        address: '',
        location: {
          type: 'Point',
          coordinates: [0, 0]
        },
        latitude: 0,
        longitude: 0,
        propertyType: 'apartment',
        roomType: 'private-room',
        availableFrom: new Date().toISOString().split('T')[0],
        minStayMonths: 1,
        maxOccupants: 1,
        bedrooms: 1,
        bathrooms: 1,
        size: 50,
        isFurnished: false,
        hasParking: false,
        hasWifi: false,
        hasKitchen: false,
        hasAirConditioning: false,
        hasHeating: false,
        hasWasher: false,
        hasTv: false,
        hasDesk: false,
        status: 'pending',
        images: [],
      });

      setPropertyImages([]);
      setShowAddProperty(false);
      fetchListings();

      
    } catch (error) {
      console.error('Error in handleAddProperty:', error);
      alert(`Error: ${error instanceof Error ? error.message : 'Failed to add property. Please try again.'}`);
    }
  };

  // Handle page change
  const handlePageChange = (newPage: number) => {
    fetchListings(newPage, pagination.itemsPerPage);
  };

  // Fetch listings when component mounts
  useEffect(() => {
    const fetchData = async () => {
      try {
        if (!user) {
          setError('Please log in to view this page');
          return;
        }

        if (user.role !== 'homeowner' && user.role !== 'admin') {
          setError('Access denied. Homeowner or admin privileges required.');
          return;
        }

        console.log('Fetching listings...');
        const response = await fetch(
          `${import.meta.env.VITE_API_URL || 'http://localhost:5000'}/api/v1/listings/me`, 
          {
            headers: {
              'Authorization': `Bearer ${localStorage.getItem('token')}`,
              'Content-Type': 'application/json',
            },
          }
        );

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.message || 'Failed to fetch listings');
        }

        const data = await response.json();
        console.log('API Response:', data);

        // Handle different response formats
        let listingsData = [];
        if (Array.isArray(data)) {
          listingsData = data;
        } else if (data && data.data && Array.isArray(data.data)) {
          listingsData = data.data;
        } else if (data && data.listings && Array.isArray(data.listings)) {
          listingsData = data.listings;
        }

        console.log('Processed listings data:', listingsData);
        
        // Log image information for each listing
        listingsData.forEach((listing: any, index: number) => {
          console.log(`\nListing #${index + 1}:`);
          console.log('ID:', listing.id);
          console.log('Title:', listing.title);
          console.log('Images:', listing.images || 'No images');
          if (listing.images && listing.images.length > 0) {
            console.log('First image path:', listing.images[0]);
            // Check if the image path is accessible
            const img = new Image();
            const imgUrl = listing.images[0].startsWith('http') 
              ? listing.images[0] 
              : `${import.meta.env.VITE_API_URL || 'http://localhost:5000'}/${listing.images[0].replace(/^[\\/]+/, '')}`;
            
            img.onload = () => {
              console.log('Image loaded successfully:', imgUrl);
            };
            img.onerror = () => {
              console.error('Failed to load image:', imgUrl);
            };
            img.src = imgUrl;
          }
        });

        setListings(listingsData);
      } catch (err) {
        console.error('Error fetching listings:', err);
        setError(err instanceof Error ? err.message : 'Failed to load listings');
      }
    };

    fetchData();
  }, [user, pagination.currentPage, pagination.itemsPerPage]);

  // Debug: log listings when they change
  useEffect(() => {
    console.log('Listings state updated:', listings);
  }, [listings]);

  if (error) {
    return (
      <div className="container">
        <h1>Owner Dashboard</h1>
        <p className="error">{error}</p>
      </div>
    );
  }

  return (
    <div className="dashboard-container">
      <div className="dashboard-header">
        <h1>My Properties</h1>
        <div className="debug-controls" style={{ marginBottom: '20px' }}>
          <button 
            onClick={() => setShowDebug(!showDebug)}
            className="btn btn-sm btn-secondary"
          >
            {showDebug ? 'Hide' : 'Show'} Debug Info
          </button>
        </div>
        {!showAddProperty && (
          <button 
            className="btn btn-primary"
            onClick={() => setShowAddProperty(true)}
          >
            Add New Property
          </button>
        )}
      </div>

      {/* Debug Information */}
      {showDebug && (
      <div className="debug-info" style={{ 
        backgroundColor: '#f8f9fa', 
        padding: '15px', 
        borderRadius: '5px', 
        marginBottom: '20px',
        border: '1px solid #ddd'
      }}>
        <h3>Debug Information</h3>
        <div style={{ maxHeight: '300px', overflowY: 'auto' }}>
          <h4>Environment:</h4>
          <pre>{JSON.stringify({
            VITE_API_URL: import.meta.env.VITE_API_URL,
            NODE_ENV: import.meta.env.MODE,
            BaseURL: window.location.origin
          }, null, 2)}</pre>
          
          <h4>Listings ({listings.length}):</h4>
          <pre>{JSON.stringify(listings.map(listing => ({
            id: listing.id,
            title: listing.title,
            images: listing.images,
            imageCount: listing.images?.length || 0,
            firstImage: listing.images?.[0],
            firstImageFullPath: listing.images?.[0] ? 
              (listing.images[0].startsWith('http') ? 
                listing.images[0] : 
                `${import.meta.env.VITE_API_URL || 'http://localhost:5000'}/${listing.images[0].replace(/^[\\/]+/, '')}`) : 
              null
          })), null, 2)}</pre>
          
          <h4>First Listing Raw:</h4>
          <pre>{JSON.stringify(listings[0] || {}, null, 2)}</pre>
        </div>
      </div>
      )}

      {showAddProperty ? (
        <div className="property-form">
          <h2>Add New Property</h2>
          <form onSubmit={handleAddProperty}>
            <div className="form-group">
              <label htmlFor="title">Title *</label>
              <input
                type="text"
                id="title"
                name="title"
                value={newProperty.title}
                onChange={handleInputChange}
                required
              />
            </div>

            <div className="form-row">
              <div className="form-group">
                <label htmlFor="propertyType">Property Type *</label>
                <select
                  id="propertyType"
                  name="propertyType"
                  value={newProperty.propertyType}
                  onChange={handleInputChange}
                  required
                  className="form-control"
                >
                  <option value="apartment">Apartment</option>
                  <option value="house">House</option>
                  <option value="condo">Condo</option>
                  <option value="townhouse">Townhouse</option>
                </select>
              </div>

              <div className="form-group">
                <label htmlFor="roomType">Room Type *</label>
                <select
                  id="roomType"
                  name="roomType"
                  value={newProperty.roomType}
                  onChange={handleInputChange}
                  required
                  className="form-control"
                >
                  <option value="private-room">Private Room</option>
                  <option value="entire-place">Entire Place</option>
                  <option value="shared-room">Shared Room</option>
                </select>
              </div>
            </div>

            <div className="form-row">
              <div className="form-group">
                <label htmlFor="bedrooms">Bedrooms *</label>
                <input
                  type="number"
                  id="bedrooms"
                  name="bedrooms"
                  min="1"
                  max="20"
                  value={newProperty.bedrooms}
                  onChange={handleInputChange}
                  required
                  className="form-control"
                />
              </div>

              <div className="form-group">
                <label htmlFor="bathrooms">Bathrooms *</label>
                <input
                  type="number"
                  id="bathrooms"
                  name="bathrooms"
                  min="1"
                  max="20"
                  step="0.5"
                  value={newProperty.bathrooms}
                  onChange={handleInputChange}
                  required
                  className="form-control"
                />
              </div>

              <div className="form-group">
                <label htmlFor="size">Size (sq ft) *</label>
                <input
                  type="number"
                  id="size"
                  name="size"
                  min="1"
                  value={newProperty.size}
                  onChange={handleInputChange}
                  required
                  className="form-control"
                />
              </div>
            </div>

            <div className="form-group">
              <label htmlFor="description">Description</label>
              <textarea
                id="description"
                name="description"
                value={newProperty.description}
                onChange={handleInputChange}
                rows={4}
                className="form-control"
              />
            </div>

            <div className="form-group">
              <label htmlFor="price">Price per month ($) *</label>
              <input
                type="number"
                id="price"
                name="price"
                value={newProperty.price}
                onChange={handleInputChange}
                min="0"
                step="0.01"
                required
              />
            </div>

            <div className="form-group">
              <label htmlFor="address">Address *</label>
              <input
                type="text"
                id="address"
                name="address"
                value={newProperty.address}
                onChange={handleInputChange}
                required
              />
            </div>

            <div className="form-group">
              <label>Available From *</label>
              <input
                type="date"
                id="availableFrom"
                name="availableFrom"
                value={newProperty.availableFrom}
                onChange={handleInputChange}
                required
                className="form-control"
                min={new Date().toISOString().split('T')[0]}
              />
            </div>

            <div className="form-group">
              <label>Amenities</label>
              <div className="amenities-grid">
                {[
                  { id: 'hasWifi', label: 'WiFi' },
                  { id: 'hasParking', label: 'Parking' },
                  { id: 'hasKitchen', label: 'Kitchen' },
                  { id: 'hasWasher', label: 'Washer' },
                  { id: 'hasTv', label: 'TV' },
                  { id: 'hasAirConditioning', label: 'Air Conditioning' },
                  { id: 'hasHeating', label: 'Heating' },
                  { id: 'hasDesk', label: 'Desk' },
                  { id: 'isFurnished', label: 'Furnished' },
                ].map(amenity => (
                  <div key={amenity.id} className="form-check">
                    <input
                      type="checkbox"
                      id={amenity.id}
                      name={amenity.id}
                      checked={!!newProperty[amenity.id as keyof NewProperty]}
                      onChange={handleInputChange}
                      className="form-check-input"
                    />
                    <label htmlFor={amenity.id} className="form-check-label">
                      {amenity.label}
                    </label>
                  </div>
                ))}
              </div>
            </div>

            <div className="form-group">
              <label>Property Images</label>
              <ImageUpload 
                onImagesChange={setPropertyImages}
                maxFiles={10}
                maxSizeMB={5}
                initialImages={[]}
              />
              <p className="form-hint">Upload high-quality images of your property (max 10 images, 5MB each)</p>
            </div>

            <div className="form-actions">
              <button
                type="button"
                className="btn btn-secondary"
                onClick={() => setShowAddProperty(false)}
              >
                Cancel
              </button>
              <button type="submit" className="btn btn-primary">
                Add Property
              </button>
            </div>
          </form>
        </div>
      ) : (
        <div className="dashboard-content">
          <div className="stats-container">
            <div className="stat-card">
              <h3>Total Properties</h3>
              <p>{listings.length || 0}</p>
            </div>
            <div className="stat-card">
              <h3>Bookings This Month</h3>
              <p>{
                Array.isArray(listings) ? listings.reduce((count, listing) => {
                  const bookings = Array.isArray(listing?.bookings) ? listing.bookings : [];
                  return count + bookings.filter(b => 
                    b && b.startDate && new Date(b.startDate).getMonth() === new Date().getMonth()
                  ).length;
                }, 0) : 0
              }</p>
            </div>
            <div className="stat-card">
              <h3>Active Listings</h3>
              <p>{Array.isArray(listings) ? listings.filter(l => l?.status === 'available').length : 0}</p>
            </div>
          </div>

          <h2>My Listings</h2>
          {!Array.isArray(listings) || listings.length === 0 ? (
            <div className="empty-state">
              <p>You don't have any properties listed yet.</p>
              <button
                type="button"
                className="btn btn-primary"
                onClick={() => setShowAddProperty(true)}
              >
                List Your First Property
              </button>
            </div>
          ) : (
            <>
              <div className="listings-grid" style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '20px', padding: '20px' }}>
                {listings
                  .filter((listing): listing is NonNullable<typeof listing> => !!listing)
                  .map((listing) => (
                    <div key={listing.id} className="property-card-container">
                      <PropertyCard 
                        listing={{
                          ...listing,
                          id: listing.id || '',
                          title: listing.title || 'Untitled Property',
                          description: listing.description || '',
                          price: listing.price || 0,
                          address: listing.address || 'No address provided',
                          status: listing.status || 'available',
                          images: Array.isArray(listing.images) ? listing.images : [],
                          bedrooms: listing.bedrooms,
                          bathrooms: listing.bathrooms,
                          size: listing.size,
                          // Add other required properties with default values
                          createdAt: listing.createdAt || new Date().toISOString(),
                          updatedAt: listing.updatedAt || new Date().toISOString(),
                          owner: listing.owner || '',
                          slug: listing.slug || '',
                          bookings: listing.bookings || []
                        }}
                        showActions={true} 
                        onDelete={handleDeleteListing}
                        onEdit={(id) => console.log('Edit listing:', id)}
                      />
                    </div>
                  ))}
              </div>
              {pagination.totalPages > 1 && (
                <div className="pagination">
                  <button 
                    onClick={() => handlePageChange(pagination.currentPage - 1)}
                    disabled={pagination.currentPage <= 1}
                    className="pagination-button"
                  >
                    Previous
                  </button>
                  <span className="pagination-info">
                    Page {pagination.currentPage} of {pagination.totalPages}
                  </span>
                  <button 
                    onClick={() => handlePageChange(pagination.currentPage + 1)}
                    disabled={pagination.currentPage >= pagination.totalPages}
                    className="pagination-button"
                  >
                    Next
                  </button>
                </div>
              )}
            </>
          )}
        </div>
      )}
    </div>
  );
};

// Export the component as default
export default OwnerDashboard;
